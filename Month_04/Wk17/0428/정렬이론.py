'''
정렬

기준에 따라 데이터를 정렬

정렬이란 " 데이터를 특정한 기준에 따라서 순서대로 나열 " 하는것을 말한다.
정렬 알고리즘으로 데이터를 정렬하면 " 이진탐색 " 이 가능해진다.
정렬 알고리즘의 종류는
선택 정렬, 삽입 정렬, 퀵정렬, 계수 정렬 등등이 있다.

선택 정렬
데이터가 무작위로 여러 개 있을 때, " 이 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고,
그 다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복하면 어떨까?"
해당 방법은 가장 원시적인 방법으로 매번 가장 작은 것을 "선택" 한다는 의미에서 선택 정렬이라고 한다.

"가장 작은것을 선택해서 앞으로 보내는 과정을 반복해서 수행하다 보면, 전체 데이터의 정렬이 이루어진다."

'''

# 선택 정렬 소스코드
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)):
    min_index = i # 가장 작은 원소의 인덱스
    for j in range(i+1, len(array)):
        if array[min_index] > array[j]:
            min_index = j
    array[i], array[min_index] = array[min_index], array[i] # 스와프
print(array)

'''
선택 정렬의 시간 복잡도

선택 정렬은 N-1번 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 한다.
또한 매번 가장 작은 수를 찾기 위해서 비교연산이 필요하다.
빅 오 표기법으로 O(N^2)
데이터가 10000개면 15초이상이 걸림 = 너무 비효율적
"그러나 특정한 리스트에서 가장 작은 데이터를 찾는일이 잦아 선택정렬에 익숙해질 필요가 있음"
'''

'''
삽입 정렬

선택 정렬은 알고리즘 문제 풀이에 사용하기에는 느린 편이다. 그렇다면 다른 접근 방법에 대해서 생각해보자

" 데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입하면 어떨까? "

삽입 정렬은 선택 정렬처럼 동작 원리를 직관적으로 이해하기 쉬운 알고리즘이다.
물론 삽입 정렬은 선택 정렬에 비해 구현 난이도가 높은 편이지만 선택 정렬에 비해 실행 시간 측면에서 더 효율적인
알고리즘으로 잘 알려져 있다.
특히 삽입 정렬은 필요할 때만 위치를 바꾸므로 
"데이터가 거의 정렬 되어 있을 때" 훨씬 효율적이다.
선택 정렬은 현재 데이터의 상태와 상관없이 무조건 모든 원소를 비교하고 위치를 바꾸는 반면 삽입정렬은 그렇지 않다.
'''

# 삽입 정렬 소스코드
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]
for i in range(1, len(array)):
    for j in range(i, 0, -1): # 인덱스 i부터 1까지 감소하며 반복하는 문법
        if array[j] < array[j-1]: # 
            array[j], array[j-1] = array[j-1], array[j] # 한 칸씩 왼쪽으로 이동
        else: # 자기보다 작은 데이터를 만나면 그 자리에서 멈춤
            break
print(array)

'''
삽입 정렬의 시간 복잡도
삽입 정렬의 시간 복잡도는 O(N^2)인데, 선택 정렬고 마찬가지로 반복문이 2번 중첩되어 사용되었다.
선택 정렬과 흡사한 시간이 소요되지만 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작한다.
보통은 삽입 정렬이 비효율적이나 정렬이 거의 되어 있는 상황에서는 퀵 정렬보다 더 강력하다.
'''

'''
퀵 정렬
가장 많이 사용되는 정렬 알고리즘

" 기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸면 어떨까? "

퀵 정렬은 기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작한다.
퀵 정렬에는 피벗이 사용된다
큰 숫자와 작은 숫자를 교환할 때, 교환하기 위한 기준을 바로 피벗이라고 표현한다.
퀵 정렬을 수행하기 전에는 피벗을 어떻게 설정할 것인지 미리 명시해야 한다.
피벗을 설정하고 리스트를 분할하는 방법에 따라서 여러 가지 방식으로 퀵 정렬을 구분하는데,
여기서는 가장 대표적인 분할 방식인 호어 분할 방식을 기준으로 퀵 정렬을 설명한다.
호어 분할 방식에서는 다음과 같은 규칙에 따라 피벗을 설정한다.
    - 리스트에서 첫 번째 데이터를 피벗으로 정한다.
이와 같이 피벗을 설정한 뒤에는 왼쪽에서부터 피벗보다 큰 데이터를 찾고, 오른쪽에서부터
피벗보다 작은 데이터를 찾는다. 그 다음 큰 데이터와 작은 데이터를 서로 교환해준다.
이러한 과정을 반복하면 피벗에 대하여 정렬이 수행된다.

'''

# 퀵 정렬 소스코드
array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array, start, end):
    if start >= end: # 원소가 1개인 경우 종료
        return
    pivot = start # 피벗은 첫 번째 원소
    left = start + 1
    right = end
    while left <= right:
        # 피벗보다 큰 데이터를 찾을 때 까지 반복
        while left <= end and array[left] <= array[pivot]:
            left += 1
        # 피벗보다 작은 데이터를 찾을 때 까지 반복
        while right > start and array[right] >= array[pivot]:
            right -= 1
        if left > right: # 엇갈렸다면 작은데이터와 피벗을 교체
            array[right], array[pivot] = array[pivot], array[right]
        if left < right:
            array[right], array[left] = array[left], array[right]

        # 분할 이후 왼쪽부분과 오른쪽 부분에서 각각 정렬 수행
        quick_sort(array, start, right -1)
        quick_sort(array, right+1, end)

quick_sort(array, 0, len(array)-1)
print(array)

# 파이썬의 장점을 살린 퀵 정렬 소스코드
# 전통의 퀵 정렬의 분할 방식과는 조금 다르고 비교 연산횟수가 증가하여 조금 비효율적이지만 직관적이고 기억하기 쉽다.
array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort_py(array):
    # 리스트가 하나 이하의 원소만 담고 있다면 종료
    if len(array) <= 1:
        return array
    pivot = array[0] # 피벗은 첫 번째 원소
    tail = array[1:] # 피벗을 제외한 리스트

    left_side = [x for x in tail if x <= pivot]
    right_side = [x for x in tail if x > pivot]

    return quick_sort_py(left_side) + [pivot] + quick_sort_py(right_side)

print(quick_sort_py(array))


'''
퀵 정렬의 시간 복잡도
O(NlogN)
'''

'''
계수정렬
계수 정렬 알고리즘은 " 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘" 이다.
모든 데이터가 양의 정수인 상황에 데이터가 N개, 데이터 중 최댓갑싱 K일 때
계수 정렬은 최악의 경우에도 수행시간 O(N+K)를 보장한다.
계수 정렬은 빠르게 동작할 뿐아니라 원리 또한 매우 간단하다.
다만 계수 정렬을 사용할 수 있는 조건은

" 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을때" 만 사용 가능하다.

일반적으로 가장 작은 데이터와 가장 큰데이터의 차이가 1,000,000을 넘지 않을 때 효과적으로 사용 가능하다
이러한 이유는 

"계수 정렬을 사용할 때 '모든 범위를 담을 수 있는 크기의 리스트를 선언' 해야 하기 때문이다.

추가로 계수 정렬은 앞서 다룬 3가지 정렬 알고리즘처럼 비교기반의 정렬 알고리즘이 아니다.
계수 정렬은 일반적으로 별도의 리스트를 선언하고 그 안에 정렬에 대한 정보를 담는다는 특징이 있다.

'''

# 계수 정렬 소스코드
# 모든 원소의 값이 0보다 크거나 같다고 가정
array = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]

# 모든 범위를 포함하는 리스트 선언(모든 값은 0으로 초기화)
count = [0] * (max(array)+1)

for i in range(len(array)):
    count[array[i]] += 1 # 각 데이터에 해당하는 인덱스의 값 증가

for i in range(len(count)): # 리스트에 기록된 정렬 정보 확인
    for j in range(count[i]):
        print(i, end=' ') # 띄어쓰기를 구분으로 등장한 횟수만큼 인덱스 출력

'''
계수 정렬의 시간 복잡도
앞서 말한대로 O(N+K)이다
계수 정렬은 앞에서부터 데이터를 하나씩 확인하면서 리스트에서 적절한 인덱스의 값을 1씩 증가시킬 뿐만 아니라,
추후에 리스트의 각 인덱스에 해당하는 값들을 확인할 때 데이터 중 최댓값의 크기만큼 반복을 수행해야 하기 때문이다.
따라서 데이터의 범위만 한정되어 있다면 효과적으로 사용할 수 있으며 항상 빠르게 동작한다.
사실상 현존하는 정렬 알고리즘 중에서 기수 정렬과 더불에 가장 빠르다고 볼 수 있다.

계수정렬의 공간 복잡도
계수 정렬은 때에 따라서 심각한 비효율성을 초래할 수 있다.
예를 들어 데이터가 0과 999,999 단 2개만 존재한다고 가정해보자.
이럴 때에도 리스트의 크기가 100만개가 되도록 선언해야 한다.
따라서 항상 사용할 수 있는 정렬 알고리즘은 아니며, 동일한 값을 가지는 데이터가 여러 개 등장할 때 적합하다.
예를들어 성적의 경우 100점을 맞은 학생이 여러 명일 수 있기 때문에 계수정렬이 효과적이다.
반면에 앞서 말한 퀵 정렬은 일반적인 경우에서 평균적으로 빠르게 동작하기 때문에 데이터의 특성을 파악하기 어렵다면
퀵 정렬을 이용하는 것이 유리하다.

다시말해 데이터의 크기가 한정되어 있고, 데이터의 크기가 많이 중복되어 있을수록 유리하며 항상 사용할 수 없다.
하지만 조건만 만족한다면 계수 정렬은 정렬해야 하는 데이터의 개수가 매우 많을 때에도 효과적으로 사용할 수 있다.
다만 일반적인 코딩 테스트 환경에서는 메모리 공간상의 제약과 입출력 시간으로 인해 입력되는 데이터 갯수를 1000만개 이상으로
설정할 수 없는 경우가 많아 정렬에서 데이터 갯수는 1000만개 미만으로 출제될 것이다.
'''


