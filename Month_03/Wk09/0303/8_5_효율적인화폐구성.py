'''
문제
N가지 종류의 화폐가 있다. 이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 M원이 되도록 하려고 한다. 
이때 각 화폐는 몇 개라도 사용할 수 있으며, 
사용한 화폐의 구성은 같지만 순서만 다른 것은 같은 경우로 구분한다. 
예를 들어 2원, 3원 단위의 화폐가 있을 때는 15원을 만들기 위해 3원을 5개 사용하는 것이 가장 최소한의 화폐 개수이다.

입력
첫째 줄에 N,M이 주어진다(1<= N <= 100, 1<= M <= 10,000)
이후의 N개의 줄에는 각 화폐의 가치가 주어진다. 화폐의 가치는 10,000보다 작거나 같은 자연수이다.
출력
첫째 줄에 경우의 수 X를 출력한다.(불가능할 때는 -1을 출력한다)

[입력 예시]
2 15
2
3

[출력 예시]
5
'''

# n, m = map(int, input().split())
# money = []
# for i in range(n):
#     money.append(list(map(int, input())))

# d = [0] * 100001

'''
문제 해석
DP의 초기 인덱스값은 화폐의 단위를 의미한다.
적은 금액부터 큰 금액까지 확인하며 차례대로 만들 수 있는 화폐의 개수를 적으면 된다.
금액 i 를 만들 수 있는 최소한의 화폐 개수를 ai 화폐의 단위를 k라고 했을 때
a(i-k)는 금액 (i-k)를 만들 수 있는 최소한의 화폐 갯수를 의미한다.

    - a(i-k)를 만드는 방법이 존재하는 경우 ai = min(ai, a(i-k) + 1)
    - a(i-k)를 만드는 방법이 존재 하지 않는 경우 ai = 10001

리스트는 K의 크기만큼 할당한다.
각 인덱스의 해당값으로 10001을 설정한다.(임의의 값임) 즉 10001은 특정 금액을 만들 수 있는
화폐 구성이 가능하지 않다는 뜻.
또한 0원의 경우 화폐를 하나도 사용하지 않았을 때 만들 수 있으므로 값을 0으로 설정한다.
초기 리스트값
인덱스  0       1        2       3       4       5       6       7
값      0     100001  100001  100001  100001  100001  100001   100001

화폐 단위 2, 3, 5 첫 번째 화폐 단위인 2부터 확인한다.
인덱스 2의 경우 1의 값을 가지고 있음 = 2원 하나를 이용해 2원을 만들 수 있음
다시말해 a2 = a0 + 1
인덱스 4의 경우 2원 2개(2+2)로 4원을 만들 수 있고 a4 = a2 + 1 이다.
인덱스  0       1        2       3       4       5       6       7
값      0     100001     1    100001     2     100001    3    100001

화폐단위 3 확인
a5 = a2 + 1로 2라는 값을 가지는데 이것은 2원 + 3원 = 5원이기 떄문

화폐단위 7
a7 = a2+1로 2라는 값을 가진다. 2원+5원 = 7원
이전단계에서 2원2개 3원1개로 3이었으나 더 작은 값이 있어 작은값으로 갱신된다.

'''

# 풀이
# 정수 N, M 입력받기
n, m = map(int, input().split())

# N개의 화폐 단위 정보를 입력받기
arr = []
for i in range(n):
    arr.append(int(input()))

# 한번 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [10001] * (m+1)

# 다이나믹 프로그래밍(보텀업) 진행
d[0] = 0
for i in range(n):
    for j in range(arr[i], m+1):
        if d[j-arr[i]] != 10001: # (i -k)원을 만드는 방법이 존재하는 경우
            d[j] = min(d[j], d[j-arr[i]] + 1)

# 계산된 결과 출력
if d[m] == 10001: # 최종적으로 M원을 만드는 방법이 없는 경우
    print(-1)
else:
    print(d[m])