'''
문제
정수 X가 주어질때 정수 X에 사용할 수 있는 연산은 다음과 같이 4가지이다.

1) X가 5로 나누어떨어지면, 5로 나눈다.

2) X가 3으로 나누어 떨어지면, 3으로 나눈다.

3) X가 2로 나누어 떨어지면, 2로 나눈다.

4) X에서 1을 뺀다.

정수 X가 주어졌을때, 연산 4개를 적절히 사용해서 1을 만들어야한다. 
이 연산을 사용하는 횟수의 최솟값을 출력해라.

X = 26일 경우
1. 26 - 1 = 25
2. 25 /5 = 5
3. 5 / 5 = 1

입력
첫째 줄에 정수 X이 주어진다. (1<=X<=30,000)
출력
첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.

[입력 예시]
26

[출력 예시]
3
'''

'''
문제 해석
점화식을 잘 생각해야 한다.
예를 들어 f[6]의 경우
1을 뺏을 때         f[5]
2로 나누었을 때     f[3] 
3으로 나누었을 때   f[2]
세가지 경우의 수가 있으며
각각의 경우의 수에는 각각 1을 뺏을 때 2, 3, 5로 나누었을 때로 나누어진다.
즉 동일한 함수들이 여러번 호출된다는 뜻이 된다. == 다이나믹 프로그래밍 이용(DP를 사용한다.)
f[6]을 토대로 점화식을 유추해 본다면
a(i) = min(a(i-1), a(i//2), a(i//3), a(i//5)) + 1이 된다
1을 더하는 이유는 이전에 나온 최솟값이 저장된 DP를 사용하면서 호출 횟수를 +1해줌으로써
현재 DP에 호출횟수(연산횟수)를 저장해 주는것
'''

# 해석한 점화식을 토대로 문제를 풀어보자.

x = int(input()) # 연산을 진행 할 정수 입력

d = [0] * 100000 # DP 초기화

for i in range(2, x+1):
    d[i] = d[i-1] + 1
    if i % 2 == 0:
        d[i] = min(d[i], d[i//2] + 1 )
    if i % 3 == 0:
        d[i] = min(d[i], d[i // 3] + 1)
    if i % 5 == 0:
        d[i] = min(d[i], d[i // 5] + 1)

print(d[x])