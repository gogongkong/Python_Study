'''
그래프 이론
크루스칼 알고리즘 = 그리디 알고리즘
위상 정렬 알고리즘 = 큐 / 스택 자료구조

그래프 = 노드와 노드사이에 연결된 간선의 정보를 가지고 있는 자료구조를 의미
서로 다른 객체(개체)가 연결되어 있다는 이야기가 나오면 가장 먼저 그래프 알고리즘을 떠올리자

트리(Tree)자료구조는 다양한 알고리즘에서 사용되므로 꼭 기억하자.

최소 힙 자료구조는 항상 부모노드가 자식 노드보다 크기가 작은 자료구조로서 트리 자료구조에 속함
트리 자료구조는 부모에서 자식으로 내려오는 계층적인 모델에 속함

방향성
그래프 - 방향 그래프 혹은 무방향 그래프
트리   - 방향 그래프

순환성
그래프 - 순환 및 비순환
트리   - 비순환

루트 노드 존재 여부
그래프 - 루트 노드가 없음
트리   - 루트 노드가 존재

노드간 관계성
그래프 - 부모와 자식 관계 없음
트리   - 부모와 자식 관계

모델의 종류
그래프 - 네트워크 모델
트리   - 계층 모델

그래프의 구현 방법은 2가지 방식이 존재
    1. 인접 행렬 : 2차원 배열을 이용하는 방식
    2. 인접 리스트 : 리스트를 사용하는 방식

2가지 모두 그래프 알고리즘에서 매우 많이 사용됨 두방식은 메모리와 속도 측면에서 구별됨

노드의 갯수가 V, 간선의 갯수가 E인 그래프일 떄
인접 행렬은 O(V^2) - 간선 정보를 저장하기 위해서
인접리스트는 O(E) - 간선의 갯수 만큼

인접 행렬은 노드A에서 특정한 노드B로 이어진 간선의 비용을 O(1)의 시간으로 즉시 알 수 있는 장점이 있음
반면에 인접 리스트는 O(V)만큼의 시간이 소요됨

인접 리스트 = 다익스트라 최단 경로 알고리즘
    - 노드의 개수가 V일 때 V개의 리스트를 만들어서 각 노드와 연결된 모든 간선에 대한 정보를 리스트에 저장

인접 행렬 =  플로이드 워셜 알고리즘
    - 모든 노드에 대하여 다른 노드로 가는 최소 비용을 V^2크기의 2차원 리스트에 저장한 뒤에 
      해당 비용을 갱신해서 최단거리 계산

노드의 갯수가 적은 경우 - 플로이드 워셜
노드와 간선의 갯수가 많으면 다익스트라(우선순위 큐 이용)

'''

'''
서로소 집합
    공통원소가 없는 두 집합

서로소 집합 자료구조
서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조

서로소 집합 자료구조는 union, find 이 2개의 연산으로 조작할 수 있다.

union 연산
    2개의 원소가 포함된 하나의 집합으로 합치는 연산.
find 연산
    특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산.

    서로소 집합구조는 합집합과 찾기 연산으로 구성됨 (합치기-찾기 자료구조라고 불리기도 함)

서로소 집합 자료구조를 구현할 때는 트리 자료구조를 이용하여 집합을 표현하는데
서로소 집합 정보가 주어졌을 때 트리 자료구조를 이용해서 집합을 표현하는 방식은 아래와 같다.

1. union(합집합) 연산을 확인하여, 서로 연결된 두 노드 A, B를 확인한다.
    i. A와 B의 루트 노드 A', B'를 각각 찾는다.
    ii. A'를 B'의 부모 노드로 설정한다.(B'가 A'를 가리키도록 한다.)
2. 모든 union(합집합) 연산을 처리할 때까지 1.번 과정을 반복한다.

실제로 구현할 대는 A'와 B'중에서 더 번호가 작은 원소가 부모 노드가 되도록 구현하는 경우가 많음
EX : A' = 1 / B' = 3 일 때 B'는 A'를 가리키도록 설정한다.
가리킨다는 표현은 부모노드로 설정한다는 의미 이며  B'가 A'를 부모 노드로 설정하는 것을 그래프로
시각화 할 때 B'와 A'를 간선으로 연결하는 형태로 그래프를 그릴 수 있다.

예를 들어 [1,2,3,4,5,6] 6개의 원소로 구성되어 있는 상황이 있을 때
다음 4개의 union 연산이 있다.
union 1, 4
union 2, 3
union 2, 4
union 5, 6
4개의 union 연산은 각각 '1과 4는 같은 집합' '2와 3은 같은 집합' '2와 4는 같은 집합' '5와 6은 같은 집합'
이라는 의미를 가지고 있다.
다시말해 총 4개의 union 연산이 존재한다는 뜻

각 원소는 그래프에서 노드로 표현되고 '같은 집합에 속한다'는 정보를 담은 union연산들은 간선으로 표현된다.
즉 6개의 노드가 있고 4개의 간선이 존재하는 그래프로 바꾸어 생각할 수 있다.

'''

# 기본적인 서로소 집합 알고리즘 소스코드

# 특정 원소가 속한 집합을 찾기
def find_parent(parent, x):
    # 루트 노드가 아니라면, 루트 노드를 찾을 때 까지 재귀적으로 호출
    if parent[x] != x:
        return find_parent(parent, parent[x])
    return x

# 두 원소가 속한 집합을 합치기
def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b

# 노드의 갯수와 간선(union 연산)의 갯수 입력받기
v, e = map(int, input().split())
parent = [0] * (v+1) # 부모 테이블 초기화

# 부모 테이블상에서, 부모를 자기 자신으로 초기화
for i in range(1, v+1):
    parent[i] = i

# union 연산을 각각 수행
for i in range(e):
    a, b = map(int, input().split())
    union_parent(parent, a, b)

# 각 원소가 속한 집합 출력
print('각 원소가 속한 집합 :',end= '')
for i in range(1, v+1):
    print(find_parent(parent, i), end=' ')
print()

# 부모 테이블 내용 출력
print('부모 테이블 : ',end='')
for i in range(1, v+1):
    print(parent[i], end=' ')

'''
[입력예시]
6 4
1 4
2 3
2 4
5 6

[출력 예시]
각 원소가 속한 집합 :1 1 1 1 5 5 
부모 테이블 : 1 1 2 1 5 5  
'''