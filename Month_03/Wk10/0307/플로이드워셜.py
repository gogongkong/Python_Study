'''
플로이드 워셜 알고리즘
    모든 지점에서 다른 모든 지점까지의 최단경로를 모두 구해야 하는 경우 사용
    기존 방식처럼 노드를 반복적으로 선택하여 경호를 확인 최단거리 테이블을 갱신하는
    방식으로 동작. 
    그러나 매번 방문하지 않은 노드중에서 최단거리를 갖는 노드를 찾을 필요가 없다.
    
    다익스트라  
        1차원 리스트 사용
        그리디 알고리즘
    플로이드 워셜 
        2차원 리스트에 최단거리를 저장
        다이나믹 프로그래밍 (점화식에 맞게 2차원 리스트를 갱신)
    
    장점
    소스코드가 짧다.

    단점
    시간 복잡도 O(N^3)

    점화식(K번 단계에 대한)
    D_ab = min(D_ab, D_ak + D+kb)
    따라서 전체적으로 3중 반복문을 이용하여 점화식에 따라 최단거리 테이블을 갱신하면 된다.
    
    점화식을 풀어서 설명하면
    "A에서 B로 가는 최소비용과 A에서 K를 거쳐 B로가는 비용"을 비교하여 더 작은 값으로 갱신
    
    즉 "바로 이동하는거리"가 "특정한 노드를 거쳐서 이동하는 거리"보다 더 많은 비용을 가진다면
    더 짧은 것으로 갱신한다는 의미
'''

# 예제
INF = int(1e9) # 무한값 10억 설정

# 노드의 갯수 및 간선의 갯수 입력 
n = int(input())
m = int(input())

# 2차원 리스트를 만들고, 모든 값을 무한으로 초기화
graph = [[INF]*(n+1) for _ in range(n+1)]

# 자기자신으로 가는 비용은 0으로 초기화
for a in range(1, n+1):
    for b in range(1, n+1):
        if a==b:
            graph[a][b] = 0

# 각 간선에 대한 정보를 입력받아, 그 값으로 초기화
for _ in range(m):
    # A에서 B로 가는 비용은 C라고 설정
    a, b, c = map(int, input().split())
    graph[a][b] = c

# 점화식에 따라 플로이드 워셜 알고리즘을 수행
for k in range(1, n+1):
    for a in range(1, n+1):
        for b in range(1, n+1):
            graph[a][b] = min(graph[a][b], graph[a][k]+graph[k][b])

#수행된 결과를 출력
for a in range(1,n+1):
    for b in range(1,n+1):
        # 도달할 수 없는 경우, 무한이라고 출력
        if graph[a][b] == INF:
            print('INF', end=' ')
        else:
            print(graph[a][b], end=' ')
    print()
        

'''
4
7
1 2 4
1 4 6
2 1 3
2 3 7
3 1 5
3 4 4
4 3 2
'''