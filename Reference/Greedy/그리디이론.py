'''
그리디 알고리즘 ( = 탐욕법)
매 순간 가장 좋아보이는 것을 고르는 방법

'가장 큰 순서대로' '가장 작은 순서대로' 같이 기준을 어느정도 제시해준다.

예제 3-1 거스름돈 (89p)
[문제]
당신은 음식점의 계산을 도와주는 점원입니다. 
카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한이 존재한다고 가정합니다. 
손님에게 거슬러 주어야 할 돈이 N원일 때 거슬러 주어야 할 동전의 최소 개수를 구하세요. 
단, 거슬러 줘야 할 돈 N은 항상 10의 배수입니다.
[입력]
1260
[출력]
6

[해설]
가장 큰 단위의 화폐부터 돈을 거슬러 주는것으로 문제를 풀어보자
'''

n = 1260
coin_type = [500, 100, 50, 10]
count = 0

for coin in coin_type:
    count += n // coin
    n = n % coin

print(count)

'''
그리디 알고리즘의 정당성

그리디 알고리즘은 모든 문제에 적용할 수 있는것은 아니다.
그리디 알고리즘으로 해법을 찾았을 때는 그 해법이 정당한지 검토해야 한다.

거스름돈 문제를 그리디 알고리즘으로 해결할 수 있는 이유는
" 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문이다."
예를들어 800원을 거슬러 줘야 할 때 화폐단위가 500, 400, 100원이라고 가정했을 때
그리디 알고리즘으로는 4개의 동전(500 + 100 + 100 + 100)이 나오지만
최적의 해는 2개의 동전(400 + 400)을 거슬러 주는 것이다.
다시 말해 이 문제에서는 큰 단위가 작은 단위의 배수 형태이므로,
"가장 큰 단위의 화폐부터 가장 작은 단위의 화폐까지 차례대로 확인하여 거슬러 주는 작업만을 수행하면 된다"는 아이디어는 정당하다.
"대부분의 그리디 알고리즘 문제는 이처럼 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야한다."

어떤 코딩 테스트 문제를 만났을 때, 바로 유형을 파악하기 어렵다면 그리디 알고리즘을 의심하고,
문제를 해결할 수 있는 탐욕적인 해결법이 존재하는지 고민해보자.
만약 오랜시간을 고민해도 그리디 알고리즘으로 해결방법을 찾을 수 없다면, 
그때는 다른 알고리즘으로 해결가능한지 고민하는것도 방법이다.

처음에 문제를 만났을 때는 이것저것 다양한 아이디어를 고려해야 한다.
가장 먼저 "10원 짜리로만 모두 거슬러 주도록 코드를 작성하면 어떻게 되지?" 라고 생각할 수있다.
그 이후에는 10원짜리로만 거슬러 주면 최적의 해를 구할 수 없다고 인식하고
다른 문제 풀이 방법을 하나씩 곰곰히 생각해보는 것이다.
그러다가 결국엔 "가장 큰 500원 짜리부터 거슬러서 가장 작은 10원까지 차례대로 거슬러 준다면 어떻게 될까?"
라고 생각하고 거스름돈 문제에서는 큰 단위가 항상 작은 단위의 배수 형태이므로 이렇게 하면 항상 최적의 해를
보장할 수 있겠구나" 까지 떠올려야 문제의 정답 판정을 받을 수 있다.

'''