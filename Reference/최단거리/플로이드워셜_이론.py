'''
플로이드 워셜 알고리즘

다익스트라 알고리즘은
"한 지점에서 다른 특정 지점까지의 최단 경로를 구해야 하는 경우" 에 사용할 수 있는 알고리즘이다.

플로이드 워셜 알고리즘은
"모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우"에 사용할 수 있는 알고리즘이다.
심지어 소스코드 또한 매우 짧아서 다익스트라 알고리즘과 비교하면 구현과정에서 어렵지 않다.

플롣이드 워셜 알고리즘은 다익스트라와 마찬가지로 "거쳐가는 노드"를 기준으로 알고리즘을 수행한다.
하지만 매번 방문하지 않은 노드 중에서 최단거리를 갖는 노드를 찾을 필요가 없다는 점이 다르다.
노드가 N개 일때 알고리즘 상으로 N번의 단계를 수행하며, 단계마다 O(N^2)의 연산을 통해
"현재 노드를 거쳐가는" 모든 경로를 고려한다.
따라서 플로이드 워셜 알고리즘의 시간 복잡도는 O(N^3)이다.

플로이드 워셜은 최단거리를 2차원 리스트에 저장하는 특징이 있다.
모든 노드에서 다른 모든 노드로 가는 최단거리 정보를 담아야 하기 때문이다.
따라서 2차원 리스트를 처리해야 하므로 N번의 단계에서 매번 N^2의 시간이 소요된다.

또한 다익스트라는 그리디 알고리즘이지만 플로이드 워셜은 다이나믹 프로그래밍이라는 점이라는 특징이 있다.

각 단계에서는 해당 노드를 거쳐 가는 경우를 고려한다.
예를 들어 1번 노드에 대해서 확인할 때는 1번 노드를 중간에 거쳐 지나가는 모든 경우를 고려하면 된다.
정확히는 A -> 1번 노드 -> B로가는 비용을 확인한 후에 최단거리를 갱신한다.
예를 들어 현재 최단거리 테이블에 A노드 --> B노드 비용이 3으로 기록되어 있을 때
A --> 1 --> B 가 2라고 한다면 A --> B를 2로 갱신하는 것이다.
따라서 현재 확인하고 있는 노드를 제외하고 N-1개의 노드 중에서 서로 다른 노드 (A, B)쌍을 선택한다.
이 후 A --> 1번노드 --> B로 가는 비용을 확인한 뒤에 최단거리를 갱신한다.
다시말해 n-1P2개의 쌍을 단계마다 반복해서 확인하면 된다.
이때 O(n-1P2)는 O(N^2)라고 볼 수 있기 때문데. 전체 시간 복잡도는 O(N^3)이라고 할 수 있다.
구체적인 (K번의 단계에 대한)점화식은 다음과 같다.
Dab = min(Dab, Dak + Dkb)
따라서 전체적으로 3중 반복문을 이용하여 이 점화식에 따라 최단 거리 테이블을 갱신하면 된다.
위의 점화식을 풀어서 설명하면
" A에서 B로 가는 최소 비용"과 "A에서 K를 거쳐 B로 가는 비용"을 비교하여 더 작은 값으로 갱신하겠다는 것이다.
즉 "바로 이동하는 거리"가 "특정한 노드를 거쳐서 이동하는 거리"보다 더 많은 비용을 가진다면
이를 더 짧은 것으로 갱신한다는 뜻이다.
'''

# 플로이드 워셜 알고리즘 소스코드 예시

INF = int(1e9)

# 노드의 갯수 및 간선의 갯수 입력받기
n = int(input())
m = int(input())

# 2차원 리스트(그래프 포함)를 만들고, 모든 값을 무한으로 초기화
graph = [[INF] * (n+1) for _ in range(n+1)]

# 자기 자신에서 자기 자신으로 가는 비용은 0으로 초기화
for a in range(1, n+1):
    for b in range(1, n+1):
        if a == b:
            graph[a][b] = 0

# 각 간선에 대한 정보를 입력받아, 그 값으로 초기화
for _ in range(m):
    # A에서 B로 가는 비용은 C라고 가정
    a, b, c = map(int, input().split())
    graph[a][b] = c

# 점화식에 따라 플로이드 워셜 알고리즘을 수행
for k in range(1, n+1):
    for a in range(1, n+1):
        for b in range(1, n+1):
            graph[a][b] = min(graph[a][b], graph[a][k] + graph[k][b])

# 수행된 결과 출력
for a in range(1, n+1):
    for b in range(1, n+1):
        # 도달할 수 없는 경우 무한 출력
        if graph[a][b] == INF:
            print("INF", end=' ')
        # 도달할 수 있는 경우 거리를 출력
        else:
            print(graph[a][b], end=' ')
    print()

'''
입력 예시
4
7
1 2 4
1 4 6
2 1 3
2 3 7
3 1 5
3 4 4
4 3 2
출력 예시
0 4 8 6 
3 0 7 9
5 9 0 4
7 11 2 0
'''