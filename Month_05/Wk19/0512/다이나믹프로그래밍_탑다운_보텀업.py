'''
다이나믹 프로그래밍

중복되는 연산을 줄이자
메모리 공간을 이용하여 연산속도를 비약적으로 상승시키는 방법
몇가지 방법이 있음
    탑다운
    보텀업
    메모이제이션

다이나믹 프로그래밍으로 해결할 수 있는 대표적인 예시로 "피보나치 수열"이 있다.
피보나치 수열은 이전 두 항의 합을 현재의 항으로 설정하는 특징이 있다.

    EX) 1 1 2 3 5 8 13 21 34 55 89

수학에서는 점화식을 이용해 수열의 항이 이어지는 형태를 간결히 표현한다.
점화식이란 인접한 항들 사이의 관계식을 의미한다.

피보나치 수열의 점화식 : An+2 = f(An+1, An) = An+1 + An

프로그래밍에서는 이러한 수열을 배열이나 리스트로 표현할 수 있다.
수열 자체가 여러 개의 수가 규칙에 따라 배열된 형태를 의미하는 것이기 때문이다.

실제로 점화식에 따라 피보나치 수열을 구하는 과정은 어떻게 표현할까?
    --> 재귀함수 이용
'''
# 피보나치 함수 소스 코드

def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x-1) + fibo(x-2)
print(fibo(4))

'''
그러나 피보나치 수열을 이렇게 작성하면 심각한 문제가 생긴다.
바로 f(n)에서 n이 커질수록 수행시간이 기하급수적으로 늘어나기 때문이다.

    원인 : 동일한 함수가 반복적으로 호출되기 때문

이러한 문제를 다이나믹 프로그래밍으로 해결할 수 있다.
다만 항상 다이나믹 프로그래밍을 사용할 수 는 없으며, 다음 조건을 만족할 때 사용 가능하다.

    - 큰 문제를 작은 문제로 나눌 수 있다.
    - 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

피보나치 수열은 이러한 조건을 만족하는 대표 문제이다.
이 문제를 메모이제이션 기법을 사용해서 풀어보자
메모이제이션은 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로
가져오는 기법을 의미한다.
방법은 단순하다. 한 번 구한 정보를 리스트에 저장하는 것이다. 재귀적으로 수행하다가 같은 정보가 필요할 때
이미 구한 정답을 그대로 리스트에서 가져오면 된다.
'''
# 메모이제이션 기법을 활용한 피보나치 수열 소스코드 (재귀함수)

# 한 번 계산한 결과를 메모이제이션하기 위한 리스트 초기화
d = [0] * 100

# 피보나치 함수를 재귀함수로 구현(탑다운 다이나믹 프로그래밍)
def fibo_memo(x):
    # 종료 조건(1 혹은 2일 때 1을 반환)
    if x == 1 or x == 2:
        return 1
    # 이미 계산한 적 있는 문제라면 그대로 반환
    if d[x] != 0:
        return d[x]
    # 아직 계산하지 않은 문제라면 점화식에 따라 피보나치 결과 반환
    d[x] = fibo_memo(x - 1) + fibo_memo(x - 2)
    return d[x]

print(fibo_memo(99))

'''
정리하자면 다이나믹 프로그래밍이란 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어
문제를 효율적으로 해결하는 알고리즘 기법이다.
퀵 정렬의 정렬할 리스트를 분할하며 전체적으로 정렬 될 수 있도록 하는 "분할정복" 알고리즘과 비슷하다
"차이점은 다이나믹 프로그래밍은 문제들이 서로 영향을 미치고 있다는 점이다."

퀵정렬은 한 번 기준 원소가 자리를 변경해서 자리를 잡게 되면 그 기준 원소의 위치는 더 이상 바뀌지 안혹
그 피벗값을 다시 처리하는 부분 문제는 존재하지 않는다.
반번 다이나믹 프로그래밍은 한 번 해결했던 문제를 다시 해결한다는 점이 특징이다.
그렇기 때문에 이미 해결된 문제에 대한 답을 저장해 놓고 이 문제는 이미 해결된 문제니까 다시 해결할 필요가 없다고
반환하는 것이다.
물론 재귀함수를 사용하면 컴퓨터 시스템에서는 함수를 다시 호출했을 때 메모리 상에 적재되는 일련의 과정을 따라야 하므로
오버헤드가 발생할 수 있다.
따라서 재귀함수 대신 반복문을 이용하여 오버헤드를 줄일 수 있다.
일반적으로 반복문을 사용한 다이나믹 프로그래밍이 더 성능이 좋다.
시간복잡도 = O(N)
'''
# 호출되는 함수 확인
d = [0] * 100

def fibo_(x):
    print('f('+str(x)+')',end=' ')
    if x == 1 or x == 2:
        return 1
    if d[x] != 0:
        return d[x]
    d[x] = fibo_(x-1) + fibo_(x-2)
    return d[x]
fibo_(6)
print()
'''
이처럼 재귀함수를 이용하여 프로그래밍 소스 코드를 작성하는 방법을, 큰 문제를 해결하기 위해 
작은 문제를 호출한다고 하여 "탑 - 다운" 방식이라고 말한다.
반면에 단순히 반복문을 이용하여 소스코드를 작성하는 경우 작은 문제부터 차근차근 답을 도출한다고 하여
"보텀 - 업" 방식이라고 말한다.
'''
# 피보나치수열 소스코드(반복문)

# 앞서 계산된 결과를 저장하기 위한 DP테이블 초기화
d = [0] * 100

# 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
d[1] = 1
d[2] = 1
n = 99
# 피보나치 함수 반복문으로 구현(보텀 업 다이나믹 프로그래밍)
for i in range(3, n+1):
    d[i] = d[i-2] + d[i-1]

print(d[n])

'''
탑 다운 방식은 "하향식" 이라고도 하며 보텀업은 "상향식" 이라고도 한다.
다이나믹 프로그래밍의 전형적인 형태는 보텀업 방식이다.
보텀업에서 사용되는 결과 저장용 리스트는 "DP 테이블" 이라고 부르며
메모이제이션은 탑 다운 방식에 국한되어 사용되는 표현이다.

또한 앞서 수열은 배열이나 리스트로 표현할 수 있다고 했는데, 메모이제이션은 때에 따라서 다른 자료형
예를 들어 사전(dict) 자료형을 이용할 수 도 있다.
사진 자료형은 수열처럼 연속적이지 않은 경우에 유용하다
예를 들어 An을 계산하고자 할 때 A0 ~ An-1 모두가 아닌 일부 작은 문제에대한 해답만 필요한 경우가 존재한다.
해당 경우에 사전 자료형을 사용하는게 효과적이다.

팁
    - 다이나믹 프로그래밍 유형인지 파악
    - 적용할 수 있는지 해결하고자 하는 부분 문제들의 중복 여부를 확인
    - 탑다운 = 재귀함수를 작성한 뒤 메모이제이션 적용하여 수정
    - 가능하다면 탑다운 보다는 보텀업으로 구현
        --> 시스템상 재귀함수의 스택 크기가 한정되어 있을 수 있음
'''